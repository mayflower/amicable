from __future__ import annotations

import json
from datetime import UTC, datetime
from typing import Any

from src.db.hasura_client import HasuraClient, HasuraError
from src.db.schema_diff import build_schema_diff, compute_schema_version
from src.db.schema_meta import persist_draft_ui_state


def _ignore_hasura_error(err: Exception) -> bool:
    msg = str(err).lower()
    return (
        "already exists" in msg
        or "already tracked" in msg
        or "already has" in msg
        or "not tracked" in msg
        or "does not exist" in msg
        or "cannot drop" in msg
        or ("relationship" in msg and "already" in msg)
    )


def _track_table(client: HasuraClient, *, schema_name: str, table: str) -> None:
    try:
        client.metadata(
            {
                "type": "pg_track_table",
                "args": {
                    "source": client.cfg.source_name,
                    "table": {"schema": schema_name, "name": table},
                },
            }
        )
    except HasuraError as e:
        if not _ignore_hasura_error(e):
            raise


def _untrack_table(client: HasuraClient, *, schema_name: str, table: str) -> None:
    try:
        client.metadata(
            {
                "type": "pg_untrack_table",
                "args": {
                    "source": client.cfg.source_name,
                    "table": {"schema": schema_name, "name": table},
                    "cascade": True,
                },
            }
        )
    except HasuraError as e:
        if not _ignore_hasura_error(e):
            raise


def _drop_relationship_metadata(
    client: HasuraClient, *, schema_name: str, table: str, relationship: str
) -> None:
    try:
        client.metadata(
            {
                "type": "pg_drop_relationship",
                "args": {
                    "source": client.cfg.source_name,
                    "table": {"schema": schema_name, "name": table},
                    "relationship": relationship,
                },
            }
        )
    except HasuraError as e:
        if not _ignore_hasura_error(e):
            raise


def _ensure_crud_permissions(
    client: HasuraClient, *, schema_name: str, table: str, role: str
) -> None:
    perms = [
        (
            "pg_create_select_permission",
            {
                "columns": "*",
                "filter": {},
                "allow_aggregations": True,
            },
        ),
        (
            "pg_create_insert_permission",
            {
                "columns": "*",
                "check": {},
                "set": {},
            },
        ),
        (
            "pg_create_update_permission",
            {
                "columns": "*",
                "filter": {},
                "check": {},
                "set": {},
            },
        ),
        (
            "pg_create_delete_permission",
            {
                "filter": {},
            },
        ),
    ]
    for typ, permission in perms:
        try:
            client.metadata(
                {
                    "type": typ,
                    "args": {
                        "source": client.cfg.source_name,
                        "table": {"schema": schema_name, "name": table},
                        "role": role,
                        "permission": permission,
                    },
                }
            )
        except HasuraError as e:
            if not _ignore_hasura_error(e):
                raise


def _ensure_object_relationship(
    client: HasuraClient,
    *,
    schema_name: str,
    table: str,
    relationship_name: str,
    from_column: str,
) -> None:
    try:
        client.metadata(
            {
                "type": "pg_create_object_relationship",
                "args": {
                    "source": client.cfg.source_name,
                    "table": {"schema": schema_name, "name": table},
                    "name": relationship_name,
                    "using": {"foreign_key_constraint_on": from_column},
                },
            }
        )
    except HasuraError as e:
        if not _ignore_hasura_error(e):
            raise


def _write_migration_files(
    backend: Any,
    *,
    diff: dict[str, Any],
) -> list[str]:
    from src.sandbox_files.sandbox_fs import SandboxFs

    fs = SandboxFs(backend)
    fs.mkdir("/db")
    fs.mkdir("/db/migrations")

    stamp = datetime.now(UTC).strftime("%Y%m%dT%H%M%SZ")
    sql_path = f"/db/migrations/{stamp}__schema_editor.sql"
    plan_path = f"/db/migrations/{stamp}__schema_editor.plan.json"

    sql_lines = [
        "-- Generated by Amicable Database Editor",
        f"-- Time (UTC): {datetime.now(UTC).isoformat()}",
        "",
    ]
    for stmt in list(diff.get("sql") or []):
        sql_lines.append(str(stmt).strip())
    sql_text = "\n".join(sql_lines).strip() + "\n"

    plan_obj = {
        "generated_at": datetime.now(UTC).isoformat(),
        "schema_name": diff.get("schema_name"),
        "operations": diff.get("operations") or [],
        "warnings": diff.get("warnings") or [],
        "destructive": bool(diff.get("destructive")),
        "destructive_details": diff.get("destructive_details") or [],
    }
    plan_text = json.dumps(plan_obj, indent=2, sort_keys=True) + "\n"

    fs.create_file(path=sql_path, content=sql_text)
    fs.create_file(path=plan_path, content=plan_text)
    return [sql_path, plan_path]


def apply_schema_changes(
    client: HasuraClient,
    *,
    app_id: str,
    schema_name: str,
    role_name: str,
    current_schema: dict[str, Any],
    draft_schema: dict[str, Any],
    backend: Any | None = None,
) -> dict[str, Any]:
    draft = dict(draft_schema)
    draft.setdefault("app_id", app_id)
    draft.setdefault("schema_name", schema_name)

    diff = build_schema_diff(current_schema, draft)

    # Keep Hasura metadata consistent before dropping SQL constraints/tables.
    for op in list(diff.get("operations") or []):
        typ = str(op.get("type") or "")
        if typ == "drop_relationship":
            _drop_relationship_metadata(
                client,
                schema_name=schema_name,
                table=str(op.get("from_table") or ""),
                relationship=str(op.get("name") or ""),
            )
        elif typ == "drop_table":
            _untrack_table(
                client,
                schema_name=schema_name,
                table=str(op.get("table") or ""),
            )

    for stmt in list(diff.get("sql") or []):
        client.run_sql(str(stmt))

    draft_norm = dict(diff.get("draft") or {})
    for table in list(draft_norm.get("tables") or []):
        if not isinstance(table, dict):
            continue
        tname = str(table.get("name") or "")
        if not tname:
            continue
        _track_table(client, schema_name=schema_name, table=tname)
        _ensure_crud_permissions(
            client,
            schema_name=schema_name,
            table=tname,
            role=role_name,
        )

    for rel in list(draft_norm.get("relationships") or []):
        if not isinstance(rel, dict):
            continue
        _ensure_object_relationship(
            client,
            schema_name=schema_name,
            table=str(rel.get("from_table") or ""),
            relationship_name=str(rel.get("name") or ""),
            from_column=str(rel.get("from_column") or ""),
        )

    persist_draft_ui_state(client, app_id=app_id, draft=draft_norm)

    migration_files: list[str] = []
    if backend is not None:
        migration_files = _write_migration_files(backend, diff=diff)

    new_version = compute_schema_version(draft_norm)
    summary = {
        "operation_count": len(list(diff.get("operations") or [])),
        "destructive": bool(diff.get("destructive")),
        "destructive_details": list(diff.get("destructive_details") or []),
    }

    return {
        "diff": diff,
        "draft": draft_norm,
        "new_version": new_version,
        "migration_files": migration_files,
        "warnings": list(diff.get("warnings") or []),
        "summary": summary,
    }
